/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Represents dynamic html controls (Input, TextArea and Select)
 * @template T
 */
var /**
 * Represents dynamic html controls (Input, TextArea and Select)
 * @template T
 */
MlkDynamicControl = /** @class */ (function () {
    function MlkDynamicControl(label, name, controlType, icon, isRequired, placeholder) {
        if (icon === void 0) { icon = "fa fa-file-text-o"; }
        if (isRequired === void 0) { isRequired = true; }
        if (placeholder === void 0) { placeholder = null; }
        /**
         * Control placeholder
         */
        this.placeholder = "";
        this.label = label;
        this.name = name;
        this.controlType = controlType;
        this.icon = icon;
        this.isRequired = isRequired;
        this.placeholder = placeholder ? placeholder : label;
    }
    return MlkDynamicControl;
}());
/**
 * Represents dynamic html controls (Input, TextArea and Select)
 * @template T
 */
export { MlkDynamicControl };
if (false) {
    /**
     * Control label
     * @type {?}
     */
    MlkDynamicControl.prototype.label;
    /**
     * Icon to be appended before the control (supports class defined icons)
     * @type {?}
     */
    MlkDynamicControl.prototype.icon;
    /**
     * Name of the control (provide variable valid names ie. no spaces prefarably api corresponding names e.g. userName)
     * @type {?}
     */
    MlkDynamicControl.prototype.name;
    /**
     * The actual control (MlkInput, MlkTextArea & MlkSelect)
     * @type {?}
     */
    MlkDynamicControl.prototype.controlType;
    /**
     * Checks if the field is required
     * @type {?}
     */
    MlkDynamicControl.prototype.isRequired;
    /**
     * Control placeholder
     * @type {?}
     */
    MlkDynamicControl.prototype.placeholder;
}
/**
 * Used to represent html input with options:
 * type: default to text,  maxLength, minLength, min, max
 */
var /**
 * Used to represent html input with options:
 * type: default to text,  maxLength, minLength, min, max
 */
MlkInput = /** @class */ (function () {
    function MlkInput(type) {
        if (type === void 0) { type = "text"; }
        /**
         * Type of input e.g. text, number, date
         */
        this.type = "text";
        this.type = type;
        this.minLength = this.min = 0;
        this.maxLength = 4000;
        this.max = 1000000000;
    }
    return MlkInput;
}());
/**
 * Used to represent html input with options:
 * type: default to text,  maxLength, minLength, min, max
 */
export { MlkInput };
if (false) {
    /**
     * Type of input e.g. text, number, date
     * @type {?}
     */
    MlkInput.prototype.type;
    /**
     * Used to validate length of the input
     * @type {?}
     */
    MlkInput.prototype.maxLength;
    /**
     * Used to validate minimum input length
     * @type {?}
     */
    MlkInput.prototype.minLength;
    /**
     * Used to validate number inputs
     * @type {?}
     */
    MlkInput.prototype.min;
    /**
     * Used to validate number inputs
     * @type {?}
     */
    MlkInput.prototype.max;
}
/**
 * Represents html textarea input
 */
var /**
 * Represents html textarea input
 */
MlkTextarea = /** @class */ (function () {
    function MlkTextarea(cols, rows) {
        if (cols === void 0) { cols = 5; }
        if (rows === void 0) { rows = 1; }
        this.cols = cols;
        this.rows = rows;
        this.maxLength = 4000;
        this.minLength = 0;
    }
    return MlkTextarea;
}());
/**
 * Represents html textarea input
 */
export { MlkTextarea };
if (false) {
    /**
     * Number textarea columns
     * @type {?}
     */
    MlkTextarea.prototype.cols;
    /**
     * Number of textarea rows
     * @type {?}
     */
    MlkTextarea.prototype.rows;
    /**
     * Validate maximum input length
     * @type {?}
     */
    MlkTextarea.prototype.maxLength;
    /**
     * Validate minimum input length
     * @type {?}
     */
    MlkTextarea.prototype.minLength;
}
/**
 * Represents html select control
 */
var /**
 * Represents html select control
 */
MlkSelect = /** @class */ (function () {
    function MlkSelect(options) {
        this.options = options;
    }
    return MlkSelect;
}());
/**
 * Represents html select control
 */
export { MlkSelect };
if (false) {
    /**
     * Select options
     * @type {?}
     */
    MlkSelect.prototype.options;
}
var MlkSelectOption = /** @class */ (function () {
    function MlkSelectOption(value, text) {
        if (text === void 0) { text = null; }
        this.value = value;
        this.text = text ? text : value;
    }
    return MlkSelectOption;
}());
export { MlkSelectOption };
if (false) {
    /**
     * Option value
     * @type {?}
     */
    MlkSelectOption.prototype.value;
    /**
     * Option text/label
     * @type {?}
     */
    MlkSelectOption.prototype.text;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWxrLWR5bmFtaWMtY29udHJvbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3N0ZXdhcmQtY2xpZW50LyIsInNvdXJjZXMiOlsibGliL2VudGl0aWVzL3dyYXBwZXJzL21say1keW5hbWljLWNvbnRyb2wudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFHQTs7Ozs7SUEwQkksMkJBQVksS0FBYSxFQUFFLElBQVksRUFBRSxXQUFjLEVBQUUsSUFBa0MsRUFDdkYsVUFBMEIsRUFBRSxXQUEwQjtRQURELHFCQUFBLEVBQUEsMEJBQWtDO1FBQ3ZGLDJCQUFBLEVBQUEsaUJBQTBCO1FBQUUsNEJBQUEsRUFBQSxrQkFBMEI7UUFOMUQ7O1dBRUc7UUFDSCxnQkFBVyxHQUFXLEVBQUUsQ0FBQztRQUlyQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDekQsQ0FBQztJQUVMLHdCQUFDO0FBQUQsQ0FBQyxBQXBDRCxJQW9DQzs7Ozs7Ozs7Ozs7SUFoQ0csa0NBQWM7Ozs7O0lBSWQsaUNBQWE7Ozs7O0lBSWIsaUNBQWE7Ozs7O0lBSWIsd0NBQWU7Ozs7O0lBSWYsdUNBQW9COzs7OztJQUlwQix3Q0FBeUI7Ozs7OztBQWlCN0I7Ozs7O0lBc0JJLGtCQUFZLElBQXFCO1FBQXJCLHFCQUFBLEVBQUEsYUFBcUI7UUFyQmpDOztXQUVHO1FBQ0gsU0FBSSxHQUFXLE1BQU0sQ0FBQztRQW1CbEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztRQUM5QixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztRQUN0QixJQUFJLENBQUMsR0FBRyxHQUFHLFVBQVUsQ0FBQztJQUMxQixDQUFDO0lBQ0wsZUFBQztBQUFELENBQUMsQUE1QkQsSUE0QkM7Ozs7Ozs7Ozs7O0lBeEJHLHdCQUFzQjs7Ozs7SUFJdEIsNkJBQWtCOzs7OztJQUlsQiw2QkFBa0I7Ozs7O0lBSWxCLHVCQUFZOzs7OztJQUlaLHVCQUFZOzs7OztBQWFoQjs7OztJQWtCSSxxQkFBWSxJQUFnQixFQUFFLElBQWdCO1FBQWxDLHFCQUFBLEVBQUEsUUFBZ0I7UUFBRSxxQkFBQSxFQUFBLFFBQWdCO1FBQzFDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFBO0lBQ3RCLENBQUM7SUFDTCxrQkFBQztBQUFELENBQUMsQUF4QkQsSUF3QkM7Ozs7Ozs7Ozs7SUFwQkcsMkJBQWM7Ozs7O0lBSWQsMkJBQWM7Ozs7O0lBSWQsZ0NBQWtCOzs7OztJQUlsQixnQ0FBa0I7Ozs7O0FBYXRCOzs7O0lBTUksbUJBQVksT0FBK0I7UUFDdkMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDM0IsQ0FBQztJQUVMLGdCQUFDO0FBQUQsQ0FBQyxBQVZELElBVUM7Ozs7Ozs7Ozs7SUFORyw0QkFBZ0M7O0FBUXBDO0lBVUkseUJBQVksS0FBYSxFQUFFLElBQW1CO1FBQW5CLHFCQUFBLEVBQUEsV0FBbUI7UUFDMUMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQ3BDLENBQUM7SUFFTCxzQkFBQztBQUFELENBQUMsQUFmRCxJQWVDOzs7Ozs7O0lBWEcsZ0NBQWM7Ozs7O0lBSWQsK0JBQWEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogUmVwcmVzZW50cyBkeW5hbWljIGh0bWwgY29udHJvbHMgKElucHV0LCBUZXh0QXJlYSBhbmQgU2VsZWN0KVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1sa0R5bmFtaWNDb250cm9sPFQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogQ29udHJvbCBsYWJlbFxyXG4gICAgICovXHJcbiAgICBsYWJlbDogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJY29uIHRvIGJlIGFwcGVuZGVkIGJlZm9yZSB0aGUgY29udHJvbCAoc3VwcG9ydHMgY2xhc3MgZGVmaW5lZCBpY29ucylcclxuICAgICAqL1xyXG4gICAgaWNvbjogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lIG9mIHRoZSBjb250cm9sIChwcm92aWRlIHZhcmlhYmxlIHZhbGlkIG5hbWVzIGllLiBubyBzcGFjZXMgcHJlZmFyYWJseSBhcGkgY29ycmVzcG9uZGluZyBuYW1lcyBlLmcuIHVzZXJOYW1lKVxyXG4gICAgICovXHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhY3R1YWwgY29udHJvbCAoTWxrSW5wdXQsIE1sa1RleHRBcmVhICYgTWxrU2VsZWN0KVxyXG4gICAgICovXHJcbiAgICBjb250cm9sVHlwZTogVDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBmaWVsZCBpcyByZXF1aXJlZFxyXG4gICAgICovXHJcbiAgICBpc1JlcXVpcmVkOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb250cm9sIHBsYWNlaG9sZGVyXHJcbiAgICAgKi9cclxuICAgIHBsYWNlaG9sZGVyOiBzdHJpbmcgPSBcIlwiO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGxhYmVsOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgY29udHJvbFR5cGU6IFQsIGljb246IHN0cmluZyA9IFwiZmEgZmEtZmlsZS10ZXh0LW9cIixcclxuICAgICAgICBpc1JlcXVpcmVkOiBib29sZWFuID0gdHJ1ZSwgcGxhY2Vob2xkZXI6IHN0cmluZyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xUeXBlID0gY29udHJvbFR5cGU7XHJcbiAgICAgICAgdGhpcy5pY29uID0gaWNvbjtcclxuICAgICAgICB0aGlzLmlzUmVxdWlyZWQgPSBpc1JlcXVpcmVkO1xyXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlciA/IHBsYWNlaG9sZGVyIDogbGFiZWw7XHJcbiAgICB9XHJcblxyXG59XHJcbi8qKlxyXG4gKiBVc2VkIHRvIHJlcHJlc2VudCBodG1sIGlucHV0IHdpdGggb3B0aW9uczpcclxuICogdHlwZTogZGVmYXVsdCB0byB0ZXh0LCAgbWF4TGVuZ3RoLCBtaW5MZW5ndGgsIG1pbiwgbWF4XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTWxrSW5wdXR7XHJcbiAgICAvKipcclxuICAgICAqIFR5cGUgb2YgaW5wdXQgZS5nLiB0ZXh0LCBudW1iZXIsIGRhdGVcclxuICAgICAqL1xyXG4gICAgdHlwZTogc3RyaW5nID0gXCJ0ZXh0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gdmFsaWRhdGUgbGVuZ3RoIG9mIHRoZSBpbnB1dFxyXG4gICAgICovXHJcbiAgICBtYXhMZW5ndGg6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byB2YWxpZGF0ZSBtaW5pbXVtIGlucHV0IGxlbmd0aFxyXG4gICAgICovXHJcbiAgICBtaW5MZW5ndGg6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byB2YWxpZGF0ZSBudW1iZXIgaW5wdXRzXHJcbiAgICAgKi9cclxuICAgIG1pbjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIHZhbGlkYXRlIG51bWJlciBpbnB1dHNcclxuICAgICAqL1xyXG4gICAgbWF4OiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nID0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMubWluTGVuZ3RoID0gdGhpcy5taW4gPSAwO1xyXG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gNDAwMDtcclxuICAgICAgICB0aGlzLm1heCA9IDEwMDAwMDAwMDA7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGh0bWwgdGV4dGFyZWEgaW5wdXRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBNbGtUZXh0YXJlYXtcclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIHRleHRhcmVhIGNvbHVtbnNcclxuICAgICAqL1xyXG4gICAgY29scz86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIG9mIHRleHRhcmVhIHJvd3NcclxuICAgICAqL1xyXG4gICAgcm93cz86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgbWF4aW11bSBpbnB1dCBsZW5ndGhcclxuICAgICAqL1xyXG4gICAgbWF4TGVuZ3RoOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIG1pbmltdW0gaW5wdXQgbGVuZ3RoXHJcbiAgICAgKi9cclxuICAgIG1pbkxlbmd0aDogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbHM6IG51bWJlciA9IDUsIHJvd3M6IG51bWJlciA9IDEpe1xyXG4gICAgICAgIHRoaXMuY29scyA9IGNvbHM7XHJcbiAgICAgICAgdGhpcy5yb3dzID0gcm93cztcclxuICAgICAgICB0aGlzLm1heExlbmd0aCA9IDQwMDA7XHJcbiAgICAgICAgdGhpcy5taW5MZW5ndGggPSAwXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGh0bWwgc2VsZWN0IGNvbnRyb2xcclxuICovXHJcbmV4cG9ydCBjbGFzcyBNbGtTZWxlY3Qge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3Qgb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBvcHRpb25zOiBBcnJheTxNbGtTZWxlY3RPcHRpb24+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEFycmF5PE1sa1NlbGVjdE9wdGlvbj4pe1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTWxrU2VsZWN0T3B0aW9ue1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcHRpb24gdmFsdWVcclxuICAgICAqL1xyXG4gICAgdmFsdWU6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogT3B0aW9uIHRleHQvbGFiZWxcclxuICAgICAqL1xyXG4gICAgdGV4dDogc3RyaW5nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlOiBzdHJpbmcsIHRleHQ6IHN0cmluZyA9IG51bGwpe1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0ID8gdGV4dCA6IHZhbHVlO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuIl19